.timeline {
  --marker-size: 1px;
  --year-font-size: 200%;
  --month-font-size: 1rem;
  --marker-colour: var(--fgc);
  display: flex;
  flex-wrap: wrap;
}

.year + .year { border-top: 1px solid var(--fgc); }

.yearIndicator, .year { width: 100% }
.year {
  z-index: 2;
  display: grid;
  grid: ". months ." 100% /
    .2rem 1fr .2rem;
  margin: 0 0 3rem 0;
}

.year > .group {
  display: flex;
  flex-wrap: wrap;
  grid-area: months;
}

.title { margin-bottom: .2rem }


/*
  You might say to me -- "thomas, my good friend,
  my brother-in-arms: why do you use `counter-reset`
  so weirdly here? You already have --timeline-year."

  "Ah", I say, smoking an imaginary tobbacco-free pipe
  and blowing out large clouds of smoke; "you see --
  it seems that CSS pseudoelements can't inherit CSS variables because they don't have true DOM parentage."

  Then, you say to me -- "if you want the year indicator
  to be inline with the main timeline block, why not
  just have it be part of the same grid as the timeline?"

  At this, i take such a long drag on my imaginary pipe
  that i nearly pass out.

  "Well. I want the year indicators in the timeline
  to be position: sticky so they show as you scroll
  over the year.
  
  However, position: sticky automatically
  sets the parent element to be the 'sticky parent' --
  which is what the sticky element sticks to the top of.

  If our sticky parent is the 'year' component of the
  timeline, the year will not stick, since the year
  component never overflows. Conversely, however
  it's not at all easy -- if it is possible at all
  to define some kind of 'grid sequence' that would
  allow us to define the repeating grid sections
  of the years themselves if the grid parent was
  the whole timeline -- which would be the only way
  to have the correct sticky parent. It is not
  possible to choose what an element's sticky parent
  is.
*/

.yearIndicator {
  counter-reset: birth-year calc(var(--timeline-year)
    - 1994) year var(--timeline-year);

  composes: GridArea from "../grid.module.css";
    grid: "birthYearIndicator . yearIndicator" /
      auto 1fr auto;
  background-color: var(--bgc);
  z-index: 1;
}

.yearIndicator::after {
  content: counter(year);
  font-size: var(--year-font-size);
  text-align: right;
  grid-area: yearIndicator;
}

.yearIndicator::before {
  grid-area: birthYearIndicator;
  content: counter(birth-year, upper-roman);
  box-sizing: border-box;
  font-size: var(--year-font-size);
}

.yearIndicator {
  position: sticky;
  top: var(--sticky-year-offset, 0);
}

.month {
  margin-right: 2rem;
}



.month::after {
  /* border-top: var(--marker-size) solid var(--marker-colour); */
  content: "";
  font-size: var(--month-font-size);
}

.month::before {
  opacity: .5;
  text-transform:lowercase;
}

.month[data-month="0"]::before { content: "Jan" }
.month[data-month="1"]::before { content: "Feb" }
.month[data-month="2"]::before { content: "Mar" }
.month[data-month="3"]::before { content: "Apr" }
.month[data-month="4"]::before { content: "May" }
.month[data-month="5"]::before { content: "Jun" }
.month[data-month="6"]::before { content: "Jul" }
.month[data-month="7"]::before { content: "Aug" }
.month[data-month="8"]::before { content: "Sep" }
.month[data-month="9"]::before { content: "Oct" }
.month[data-month="10"]::before { content: "Nov" }
.month[data-month="11"]::before { content: "Dec" }

.event {
  max-width: 30rem;
  box-sizing: border-box;
  margin: 1em 0 1em 3em;
  text-transform: lowercase;
}

.event::before {
  opacity: .7;
  content: "- ";
  display: inline;
}

.duration { display: inline }
.duration:before { content: "(" }
.duration:after { content: ")" }

.event p:first-of-type { display:inline }
.event p:first-of-type:before { content: " " }
